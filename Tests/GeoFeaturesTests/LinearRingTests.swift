///
///  LinearRingTests.swift
///
///  Copyright (c) 2016 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 2/10/2016.
///
import XCTest
@testable import GeoFeatures

///
/// NOTE: This file was auto generated by gyb from file CoordinateCollectionTypesTests.swift.gyb using the following command.
///
/// gyb --line-directive '' -DGeometryType=LinearRing -o LinearRing.swift CoordinateCollectionTypesTests.swift.gyb
///
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///

// MARK: - Coordinate, FloatingPrecision, Cartesian -

class LinearRingCoordinate2DFloatingPrecisionCartesianTests: XCTestCase {

    let precision = FloatingPrecision()
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? FloatingPrecision, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0), (x: 2.0, y: 2.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0), (x: 2.0, y: 2.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: Collection conformance

    func testAppend() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0)]

        input.append(Coordinate(x: 1.0, y: 1.0))

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testAppendContentsOf() {

        let input1 = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)
        var input2 = LinearRing(precision: precision, coordinateSystem: cs)

        input2.append(contentsOf: input1)

        XCTAssertEqual(input1, input2)
    }

    func testAppendContentsOfCoordinates() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)]

        input.append(contentsOf: expected)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
            return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testInsert() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 2.0, y: 2.0), Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)]

        input.insert(Coordinate(x: 2.0, y: 2.0), at: 0)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    // MARK: Swift.Collection Conformance

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.0, y: 1.0)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0))
    }

    func testEquals() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs).equals(LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)), true)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs).count, 2)
    }
}

// MARK: - Coordinate, FloatingPrecision, Cartesian -

class LinearRingCoordinate2DMFloatingPrecisionCartesianTests: XCTestCase {

    let precision = FloatingPrecision()
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? FloatingPrecision, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, m: 1.0), (x: 2.0, y: 2.0, m: 2.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, m: 1.0), (x: 2.0, y: 2.0, m: 2.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: Collection conformance

    func testAppend() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, m: 1.0)]

        input.append(Coordinate(x: 1.0, y: 1.0, m: 1.0))

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testAppendContentsOf() {

        let input1 = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)
        var input2 = LinearRing(precision: precision, coordinateSystem: cs)

        input2.append(contentsOf: input1)

        XCTAssertEqual(input1, input2)
    }

    func testAppendContentsOfCoordinates() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)]

        input.append(contentsOf: expected)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
            return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testInsert() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)]

        input.insert(Coordinate(x: 2.0, y: 2.0, m: 2.0), at: 0)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    // MARK: Swift.Collection Conformance

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, m: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.0, y: 1.0, m: 1.0)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, m: 1.0))
    }

    func testEquals() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs).equals(LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)), true)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs).count, 2)
    }
}

// MARK: - Coordinate, FloatingPrecision, Cartesian -

class LinearRingCoordinate3DFloatingPrecisionCartesianTests: XCTestCase {

    let precision = FloatingPrecision()
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? FloatingPrecision, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0), (x: 2.0, y: 2.0, z: 2.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0), (x: 2.0, y: 2.0, z: 2.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: Collection conformance

    func testAppend() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0)]

        input.append(Coordinate(x: 1.0, y: 1.0, z: 1.0))

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testAppendContentsOf() {

        let input1 = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs)
        var input2 = LinearRing(precision: precision, coordinateSystem: cs)

        input2.append(contentsOf: input1)

        XCTAssertEqual(input1, input2)
    }

    func testAppendContentsOfCoordinates() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)]

        input.append(contentsOf: expected)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
            return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testInsert() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)]

        input.insert(Coordinate(x: 2.0, y: 2.0, z: 2.0), at: 0)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    // MARK: Swift.Collection Conformance

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, z: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.0, y: 1.0, z: 1.0)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, z: 1.0))
    }

    func testEquals() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs).equals(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs)), true)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs).count, 2)
    }
}

// MARK: - Coordinate, FloatingPrecision, Cartesian -

class LinearRingCoordinate3DMFloatingPrecisionCartesianTests: XCTestCase {

    let precision = FloatingPrecision()
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? FloatingPrecision, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0, m: 1.0), (x: 2.0, y: 2.0, z: 2.0, m: 2.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0, m: 1.0), (x: 2.0, y: 2.0, z: 2.0, m: 2.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: Collection conformance

    func testAppend() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)]

        input.append(Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0))

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testAppendContentsOf() {

        let input1 = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)
        var input2 = LinearRing(precision: precision, coordinateSystem: cs)

        input2.append(contentsOf: input1)

        XCTAssertEqual(input1, input2)
    }

    func testAppendContentsOfCoordinates() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)]

        input.append(contentsOf: expected)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
            return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testInsert() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)]

        input.insert(Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), at: 0)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    // MARK: Swift.Collection Conformance

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0))
    }

    func testEquals() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs).equals(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)), true)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs).count, 2)
    }
}

// MARK: - Coordinate, FixedPrecision, Cartesian -

class LinearRingCoordinate2DFixedPrecisionCartesianTests: XCTestCase {

    let precision = FixedPrecision(scale: 100)
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? FixedPrecision, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0), (x: 2.0, y: 2.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0), (x: 2.0, y: 2.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: Collection conformance

    func testAppend() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0)]

        input.append(Coordinate(x: 1.001, y: 1.001))

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testAppendContentsOf() {

        let input1 = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)], precision: precision, coordinateSystem: cs)
        var input2 = LinearRing(precision: precision, coordinateSystem: cs)

        input2.append(contentsOf: input1)

        XCTAssertEqual(input1, input2)
    }

    func testAppendContentsOfCoordinates() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)]

        input.append(contentsOf: expected)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
            return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testInsert() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 2.0, y: 2.0), Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)]

        input.insert(Coordinate(x: 2.002, y: 2.002), at: 0)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    // MARK: Swift.Collection Conformance

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.001, y: 1.001)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0))
    }

    func testEquals() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)], precision: precision, coordinateSystem: cs).equals(LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)), true)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)], precision: precision, coordinateSystem: cs).count, 2)
    }
}

// MARK: - Coordinate, FixedPrecision, Cartesian -

class LinearRingCoordinate2DMFixedPrecisionCartesianTests: XCTestCase {

    let precision = FixedPrecision(scale: 100)
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? FixedPrecision, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, m: 1.0), (x: 2.0, y: 2.0, m: 2.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, m: 1.0), (x: 2.0, y: 2.0, m: 2.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: Collection conformance

    func testAppend() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, m: 1.0)]

        input.append(Coordinate(x: 1.001, y: 1.001, m: 1.001))

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testAppendContentsOf() {

        let input1 = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)
        var input2 = LinearRing(precision: precision, coordinateSystem: cs)

        input2.append(contentsOf: input1)

        XCTAssertEqual(input1, input2)
    }

    func testAppendContentsOfCoordinates() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)]

        input.append(contentsOf: expected)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
            return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testInsert() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)]

        input.insert(Coordinate(x: 2.002, y: 2.002, m: 2.002), at: 0)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    // MARK: Swift.Collection Conformance

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, m: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.001, y: 1.001, m: 1.001)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, m: 1.0))
    }

    func testEquals() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs).equals(LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)), true)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs).count, 2)
    }
}

// MARK: - Coordinate, FixedPrecision, Cartesian -

class LinearRingCoordinate3DFixedPrecisionCartesianTests: XCTestCase {

    let precision = FixedPrecision(scale: 100)
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? FixedPrecision, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0), (x: 2.0, y: 2.0, z: 2.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0), (x: 2.0, y: 2.0, z: 2.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: Collection conformance

    func testAppend() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0)]

        input.append(Coordinate(x: 1.001, y: 1.001, z: 1.001))

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testAppendContentsOf() {

        let input1 = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)], precision: precision, coordinateSystem: cs)
        var input2 = LinearRing(precision: precision, coordinateSystem: cs)

        input2.append(contentsOf: input1)

        XCTAssertEqual(input1, input2)
    }

    func testAppendContentsOfCoordinates() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)]

        input.append(contentsOf: expected)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
            return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testInsert() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)]

        input.insert(Coordinate(x: 2.002, y: 2.002, z: 2.002), at: 0)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    // MARK: Swift.Collection Conformance

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, z: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.001, y: 1.001, z: 1.001)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, z: 1.0))
    }

    func testEquals() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)], precision: precision, coordinateSystem: cs).equals(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs)), true)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)], precision: precision, coordinateSystem: cs).count, 2)
    }
}

// MARK: - Coordinate, FixedPrecision, Cartesian -

class LinearRingCoordinate3DMFixedPrecisionCartesianTests: XCTestCase {

    let precision = FixedPrecision(scale: 100)
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? FixedPrecision, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0, m: 1.0), (x: 2.0, y: 2.0, z: 2.0, m: 2.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0, m: 1.0), (x: 2.0, y: 2.0, z: 2.0, m: 2.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: Collection conformance

    func testAppend() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)]

        input.append(Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001))

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testAppendContentsOf() {

        let input1 = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)
        var input2 = LinearRing(precision: precision, coordinateSystem: cs)

        input2.append(contentsOf: input1)

        XCTAssertEqual(input1, input2)
    }

    func testAppendContentsOfCoordinates() {

        var input = LinearRing(precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)]

        input.append(contentsOf: expected)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
            return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testInsert() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)]

        input.insert(Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), at: 0)

        XCTAssertTrue(input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    // MARK: Swift.Collection Conformance

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0))
    }

    func testEquals() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs).equals(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)), true)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs).count, 2)
    }
}
