///
///  LinearRingTests.swift
///
///  Copyright (c) 2016 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 2/10/2016.
///
import XCTest
@testable import GeoFeatures

///
/// NOTE: This file was auto generated by gyb from file CoordinateCollectionTypesTests.swift.gyb using the following command.
///
/// gyb --line-directive '' -DGeometryType=LinearRing -o LinearRing.swift CoordinateCollectionTypesTests.swift.gyb
///
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///

// MARK: - Coordinate, FloatingPrecision, Cartesian -

class LinearRingCoordinate2DFloatingPrecisionCartesianTests: XCTestCase {

    let precision = Floating()
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? Floating, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitConverting() {

        let input = LinearRing(converting: LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitWithArrayLiteral() {
        let input: LinearRing = [Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)]
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)])

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0), (x: 2.0, y: 2.0), (x: 2.0, y: 1.0), (x: 1.0, y: 1.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0), (x: 2.0, y: 2.0), (x: 2.0, y: 1.0), (x: 1.0, y: 1.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: MutableCollection Conformance

    func testStartIndex() {

        let input    = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = 0

        XCTAssertEqual(input.startIndex, expected)
    }

    func testEndIndex() {

        let input    = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = 4

        XCTAssertEqual(input.endIndex, expected)
    }

    func testIndexAfter() {

        let input    = 0
        let expected = 1

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs).index(after: input), expected)
    }

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.0, y: 1.0)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0))
    }

    // MARK: RangeReplaceableCollection Conformance

    func testReplaceSubrangeAppend() {

        var input = (geometry: LinearRing(precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 1.0, y: 1.0)])
        let expected = [Coordinate(x: 1.0, y: 1.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeInsert() {

        var input = (geometry: LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.0, y: 2.0)])
        let expected = [Coordinate(x: 2.0, y: 2.0), Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeReplace() {

        var input = (geometry: LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.0, y: 2.0)])
        let expected = [Coordinate(x: 2.0, y: 2.0), Coordinate(x: 1.0, y: 1.0)]

        input.geometry.replaceSubrange(0..<1, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testDoubleEqualsTrue() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertEqual(input, expected)
    }

    func testDoubleEqualsFalse() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)
        XCTAssertNotEqual(input, expected)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs).count, 4)
    }
}

// MARK: - Coordinate, FloatingPrecision, Cartesian -

class LinearRingCoordinate2DMFloatingPrecisionCartesianTests: XCTestCase {

    let precision = Floating()
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? Floating, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitConverting() {

        let input = LinearRing(converting: LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitWithArrayLiteral() {
        let input: LinearRing = [Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)]
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)])

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, m: 1.0), (x: 2.0, y: 2.0, m: 2.0), (x: 2.0, y: 1.0, m: 1.0), (x: 1.0, y: 1.0, m: 1.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, m: 1.0), (x: 2.0, y: 2.0, m: 2.0), (x: 2.0, y: 1.0, m: 1.0), (x: 1.0, y: 1.0, m: 1.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: MutableCollection Conformance

    func testStartIndex() {

        let input    = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = 0

        XCTAssertEqual(input.startIndex, expected)
    }

    func testEndIndex() {

        let input    = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = 4

        XCTAssertEqual(input.endIndex, expected)
    }

    func testIndexAfter() {

        let input    = 0
        let expected = 1

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs).index(after: input), expected)
    }

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, m: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.0, y: 1.0, m: 1.0)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, m: 1.0))
    }

    // MARK: RangeReplaceableCollection Conformance

    func testReplaceSubrangeAppend() {

        var input = (geometry: LinearRing(precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 1.0, y: 1.0, m: 1.0)])
        let expected = [Coordinate(x: 1.0, y: 1.0, m: 1.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeInsert() {

        var input = (geometry: LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.0, y: 2.0, m: 2.0)])
        let expected = [Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeReplace() {

        var input = (geometry: LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.0, y: 2.0, m: 2.0)])
        let expected = [Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)]

        input.geometry.replaceSubrange(0..<1, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testDoubleEqualsTrue() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertEqual(input, expected)
    }

    func testDoubleEqualsFalse() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)
        XCTAssertNotEqual(input, expected)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs).count, 4)
    }
}

// MARK: - Coordinate, FloatingPrecision, Cartesian -

class LinearRingCoordinate3DFloatingPrecisionCartesianTests: XCTestCase {

    let precision = Floating()
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? Floating, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitConverting() {

        let input = LinearRing(converting: LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitWithArrayLiteral() {
        let input: LinearRing = [Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)]
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)])

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0), (x: 2.0, y: 2.0, z: 2.0), (x: 2.0, y: 2.0, z: 1.0), (x: 1.0, y: 1.0, z: 1.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0), (x: 2.0, y: 2.0, z: 2.0), (x: 2.0, y: 2.0, z: 1.0), (x: 1.0, y: 1.0, z: 1.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: MutableCollection Conformance

    func testStartIndex() {

        let input    = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = 0

        XCTAssertEqual(input.startIndex, expected)
    }

    func testEndIndex() {

        let input    = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = 4

        XCTAssertEqual(input.endIndex, expected)
    }

    func testIndexAfter() {

        let input    = 0
        let expected = 1

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs).index(after: input), expected)
    }

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, z: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.0, y: 1.0, z: 1.0)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, z: 1.0))
    }

    // MARK: RangeReplaceableCollection Conformance

    func testReplaceSubrangeAppend() {

        var input = (geometry: LinearRing(precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 1.0, y: 1.0, z: 1.0)])
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeInsert() {

        var input = (geometry: LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.0, y: 2.0, z: 2.0)])
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeReplace() {

        var input = (geometry: LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.0, y: 2.0, z: 2.0)])
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)]

        input.geometry.replaceSubrange(0..<1, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testDoubleEqualsTrue() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertEqual(input, expected)
    }

    func testDoubleEqualsFalse() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertNotEqual(input, expected)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs).count, 4)
    }
}

// MARK: - Coordinate, FloatingPrecision, Cartesian -

class LinearRingCoordinate3DMFloatingPrecisionCartesianTests: XCTestCase {

    let precision = Floating()
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? Floating, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitConverting() {

        let input = LinearRing(converting: LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitWithArrayLiteral() {
        let input: LinearRing = [Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)]
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)])

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0, m: 1.0), (x: 2.0, y: 2.0, z: 2.0, m: 2.0), (x: 2.0, y: 2.0, z: 1.0, m: 1.0), (x: 1.0, y: 1.0, z: 1.0, m: 1.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0, m: 1.0), (x: 2.0, y: 2.0, z: 2.0, m: 2.0), (x: 2.0, y: 2.0, z: 1.0, m: 1.0), (x: 1.0, y: 1.0, z: 1.0, m: 1.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: MutableCollection Conformance

    func testStartIndex() {

        let input    = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = 0

        XCTAssertEqual(input.startIndex, expected)
    }

    func testEndIndex() {

        let input    = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = 4

        XCTAssertEqual(input.endIndex, expected)
    }

    func testIndexAfter() {

        let input    = 0
        let expected = 1

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs).index(after: input), expected)
    }

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0))
    }

    // MARK: RangeReplaceableCollection Conformance

    func testReplaceSubrangeAppend() {

        var input = (geometry: LinearRing(precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)])
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeInsert() {

        var input = (geometry: LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)])
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeReplace() {

        var input = (geometry: LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)])
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)]

        input.geometry.replaceSubrange(0..<1, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testDoubleEqualsTrue() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertEqual(input, expected)
    }

    func testDoubleEqualsFalse() {

        let input = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertNotEqual(input, expected)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs).count, 4)
    }
}

// MARK: - Coordinate, Fixed, Cartesian -

class LinearRingCoordinate2DFixedCartesianTests: XCTestCase {

    let precision = Fixed(scale: 100)
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? Fixed, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitConverting() {

        let input = LinearRing(converting: LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitWithArrayLiteral() {
        let input: LinearRing = [Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)]
        let expected = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)])

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0), (x: 2.0, y: 2.0), (x: 2.0, y: 1.0), (x: 1.0, y: 1.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0), (x: 2.0, y: 2.0), (x: 2.0, y: 1.0), (x: 1.0, y: 1.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: MutableCollection Conformance

    func testStartIndex() {

        let input    = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = 0

        XCTAssertEqual(input.startIndex, expected)
    }

    func testEndIndex() {

        let input    = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = 4

        XCTAssertEqual(input.endIndex, expected)
    }

    func testIndexAfter() {

        let input    = 0
        let expected = 1

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs).index(after: input), expected)
    }

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.001, y: 1.001)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0))
    }

    // MARK: RangeReplaceableCollection Conformance

    func testReplaceSubrangeAppend() {

        var input = (geometry: LinearRing(precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 1.001, y: 1.001)])
        let expected = [Coordinate(x: 1.0, y: 1.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeInsert() {

        var input = (geometry: LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.002, y: 2.002)])
        let expected = [Coordinate(x: 2.0, y: 2.0), Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeReplace() {

        var input = (geometry: LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.002, y: 2.002)])
        let expected = [Coordinate(x: 2.0, y: 2.0), Coordinate(x: 1.0, y: 1.0)]

        input.geometry.replaceSubrange(0..<1, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testDoubleEqualsTrue() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertEqual(input, expected)
    }

    func testDoubleEqualsFalse() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 2.0, y: 2.0), Coordinate(x: 2.0, y: 1.0), Coordinate(x: 1.0, y: 1.0), Coordinate(x: 2.0, y: 2.0)], precision: precision, coordinateSystem: cs)
        XCTAssertNotEqual(input, expected)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001), Coordinate(x: 2.002, y: 2.002), Coordinate(x: 2.002, y: 1.001), Coordinate(x: 1.001, y: 1.001)], precision: precision, coordinateSystem: cs).count, 4)
    }
}

// MARK: - Coordinate, Fixed, Cartesian -

class LinearRingCoordinate2DMFixedCartesianTests: XCTestCase {

    let precision = Fixed(scale: 100)
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? Fixed, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitConverting() {

        let input = LinearRing(converting: LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitWithArrayLiteral() {
        let input: LinearRing = [Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)]
        let expected = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)])

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, m: 1.0), (x: 2.0, y: 2.0, m: 2.0), (x: 2.0, y: 1.0, m: 1.0), (x: 1.0, y: 1.0, m: 1.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, m: 1.0), (x: 2.0, y: 2.0, m: 2.0), (x: 2.0, y: 1.0, m: 1.0), (x: 1.0, y: 1.0, m: 1.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: MutableCollection Conformance

    func testStartIndex() {

        let input    = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = 0

        XCTAssertEqual(input.startIndex, expected)
    }

    func testEndIndex() {

        let input    = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = 4

        XCTAssertEqual(input.endIndex, expected)
    }

    func testIndexAfter() {

        let input    = 0
        let expected = 1

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs).index(after: input), expected)
    }

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, m: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.001, y: 1.001, m: 1.001)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, m: 1.0))
    }

    // MARK: RangeReplaceableCollection Conformance

    func testReplaceSubrangeAppend() {

        var input = (geometry: LinearRing(precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 1.001, y: 1.001, m: 1.001)])
        let expected = [Coordinate(x: 1.0, y: 1.0, m: 1.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeInsert() {

        var input = (geometry: LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.002, y: 2.002, m: 2.002)])
        let expected = [Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeReplace() {

        var input = (geometry: LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.002, y: 2.002, m: 2.002)])
        let expected = [Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)]

        input.geometry.replaceSubrange(0..<1, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testDoubleEqualsTrue() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertEqual(input, expected)
    }

    func testDoubleEqualsFalse() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 2.0, y: 2.0, m: 2.0), Coordinate(x: 2.0, y: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, m: 2.0)], precision: precision, coordinateSystem: cs)
        XCTAssertNotEqual(input, expected)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, m: 2.002), Coordinate(x: 2.002, y: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs).count, 4)
    }
}

// MARK: - Coordinate, Fixed, Cartesian -

class LinearRingCoordinate3DFixedCartesianTests: XCTestCase {

    let precision = Fixed(scale: 100)
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? Fixed, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitConverting() {

        let input = LinearRing(converting: LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitWithArrayLiteral() {
        let input: LinearRing = [Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)]
        let expected = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)])

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0), (x: 2.0, y: 2.0, z: 2.0), (x: 2.0, y: 2.0, z: 1.0), (x: 1.0, y: 1.0, z: 1.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0), (x: 2.0, y: 2.0, z: 2.0), (x: 2.0, y: 2.0, z: 1.0), (x: 1.0, y: 1.0, z: 1.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: MutableCollection Conformance

    func testStartIndex() {

        let input    = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = 0

        XCTAssertEqual(input.startIndex, expected)
    }

    func testEndIndex() {

        let input    = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = 4

        XCTAssertEqual(input.endIndex, expected)
    }

    func testIndexAfter() {

        let input    = 0
        let expected = 1

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs).index(after: input), expected)
    }

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, z: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.001, y: 1.001, z: 1.001)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, z: 1.0))
    }

    // MARK: RangeReplaceableCollection Conformance

    func testReplaceSubrangeAppend() {

        var input = (geometry: LinearRing(precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 1.001, y: 1.001, z: 1.001)])
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeInsert() {

        var input = (geometry: LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.002, y: 2.002, z: 2.002)])
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeReplace() {

        var input = (geometry: LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.002, y: 2.002, z: 2.002)])
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)]

        input.geometry.replaceSubrange(0..<1, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testDoubleEqualsTrue() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 1.001), Coordinate(x: 2.002, y: 1.001, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertEqual(input, expected)
    }

    func testDoubleEqualsFalse() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 1.001), Coordinate(x: 2.002, y: 1.001, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 2.0, y: 2.0, z: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertNotEqual(input, expected)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002), Coordinate(x: 2.001, y: 2.002, z: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001)], precision: precision, coordinateSystem: cs).count, 4)
    }
}

// MARK: - Coordinate, Fixed, Cartesian -

class LinearRingCoordinate3DMFixedCartesianTests: XCTestCase {

    let precision = Fixed(scale: 100)
    let cs        = Cartesian()

    // MARK: Construction

    func testInitWithPrecisionAndCRS() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty, true)
    }

    func testInitWithPrecision() {

        XCTAssertEqual(LinearRing(precision: precision).precision as? Fixed, precision)
    }

    func testInitWithCRS() {

        XCTAssertEqual(LinearRing(coordinateSystem: cs).coordinateSystem as? Cartesian, cs)
    }

    func testInitConverting() {

        let input = LinearRing(converting: LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitCopy() {

        let input = LinearRing(other: LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)]), precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    func testInitWithArrayLiteral() {
        let input: LinearRing = [Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)]
        let expected = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)])

        XCTAssertTrue(
            (input.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                    return lhs == rhs
            }
        ), "\(input) is not equal to \(expected)")
    }

    // MARK: CustomStringConvertible & CustomDebugStringConvertible

    func testDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0, m: 1.0), (x: 2.0, y: 2.0, z: 2.0, m: 2.0), (x: 2.0, y: 2.0, z: 1.0, m: 1.0), (x: 1.0, y: 1.0, z: 1.0, m: 1.0)])"

        XCTAssertEqual(input.description, expected)
    }

    func testDebugDescription() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = "LinearRing([(x: 1.0, y: 1.0, z: 1.0, m: 1.0), (x: 2.0, y: 2.0, z: 2.0, m: 2.0), (x: 2.0, y: 2.0, z: 1.0, m: 1.0), (x: 1.0, y: 1.0, z: 1.0, m: 1.0)])"

        XCTAssertEqual(input.debugDescription, expected)
    }

    // MARK: MutableCollection Conformance

    func testStartIndex() {

        let input    = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = 0

        XCTAssertEqual(input.startIndex, expected)
    }

    func testEndIndex() {

        let input    = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = 4

        XCTAssertEqual(input.endIndex, expected)
    }

    func testIndexAfter() {

        let input    = 0
        let expected = 1

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs).index(after: input), expected)
    }

    func testSubscriptGet() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)

        XCTAssertEqual(input[1], Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0))
    }

    func testSubscriptSet() {

        var input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)

        input[1] = Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)

        XCTAssertEqual(input[1], Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0))
    }

    // MARK: RangeReplaceableCollection Conformance

    func testReplaceSubrangeAppend() {

        var input = (geometry: LinearRing(precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)])
        let expected = [Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
        }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeInsert() {

        var input = (geometry: LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)])
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0)]

        input.geometry.replaceSubrange(0..<0, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testReplaceSubrangeReplace() {

        var input = (geometry: LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs), newElements: [Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002)])
        let expected = [Coordinate(x: 2.0, y: 2.0, z: 2.0, m: 2.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)]

        input.geometry.replaceSubrange(0..<1, with: input.newElements)

        XCTAssertTrue(input.geometry.elementsEqual(expected) { (lhs: Coordinate, rhs: Coordinate) -> Bool in
                return lhs == rhs
            }, "\(input) is not equal to \(expected)")
    }

    func testDoubleEqualsTrue() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertEqual(input, expected)
    }

    func testDoubleEqualsFalse() {

        let input = LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs)
        let expected = LinearRing([Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 1.0, y: 1.0, z: 1.0, m: 1.0), Coordinate(x: 2.0, y: 2.0, z: 1.0, m: 1.0)], precision: precision, coordinateSystem: cs)
        XCTAssertNotEqual(input, expected)
    }

    func testIsEmpty() {

        XCTAssertEqual(LinearRing(precision: precision, coordinateSystem: cs).isEmpty(), true)
    }

    func testIsEmptyFalse() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs).isEmpty(), false)
    }

    func testCount() {

        XCTAssertEqual(LinearRing([Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001), Coordinate(x: 2.002, y: 2.002, z: 2.002, m: 2.002), Coordinate(x: 2.002, y: 2.002, z: 1.001, m: 1.001), Coordinate(x: 1.001, y: 1.001, z: 1.001, m: 1.001)], precision: precision, coordinateSystem: cs).count, 4)
    }
}
